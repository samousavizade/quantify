---
title: Samuelson Multiplier Accelerator
draft: false
summary: test
---

import TOCInline from 'pliny/ui/TOCInline';

<TOCInline toc={props.toc} asDisclosure />

# The Samuelson Multiplier-Accelerator Model

## Table of Contents

- [The Samuelson Multiplier-Accelerator Model](#Samuelson-Multiplier-Accelerator)
- [Introduction](#Overview)
- [Model Specifications](#Details)
- [Practical Application](#Implementation)
- [Random Disturbances](#Stochastic-Shocks)
- [Public Expenditure](#Government-Spending)
- [Encapsulating the Model in a Class](#Wrapping-Everything-Into-a-Class)
- [Applying the LinearStateSpace Class](#Using-the-LinearStateSpace-Class)
- [Simplified Multiplier Model](#Pure-Multiplier-Model)
- [Conclusion](#Summary)

This lecture requires the following libraries in addition to those included in Anaconda:

```python
!pip install quantecon
```

## Introduction

In this lecture, we'll explore deterministic and stochastic versions of Paul Samuelson's renowned multiplier accelerator model [[Samuelson, 1939](/courses/Introduction-to-Quantitative-Economics/References#id88)].

We'll build upon the Solow model class.

Our goals are to:

- Provide a more comprehensive example of OOP and classes
- Examine a well-known economic model
- Review linear difference equations, both deterministic and stochastic

Let's begin with some standard imports:

```python
import matplotlib.pyplot as plt
plt.rcParams["figure.figsize"] = (11, 5)  #set default figure size
import numpy as np
```

We'll also employ the following for various tasks outlined below:

```python
from quantecon import LinearStateSpace
import cmath
import math
import sympy
from sympy import Symbol, init_printing
from cmath import sqrt
```

    OMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.

### Samuelson's Model Explained

Samuelson employed a _second-order linear difference equation_ to
model national output based on three key components:

- A _national output identity_ stating that national output or income equals
  the sum of consumption, investment, and government spending.
- A Keynesian _consumption function_ asserting that consumption in
  period $ t $ equals a constant multiplied by national output in period $ t-1 $.
- An investment _accelerator_ stating that investment in period
  $ t $ equals a constant (the _accelerator coefficient_)
  multiplied by the change in output between periods $ t-1 $ and
  $ t-2 $.

The sum of consumption, investment, and government spending
forms _aggregate demand,_ which automatically generates an
equal amount of _aggregate supply_.

(For more on linear difference equations, see [this link](https://en.wikipedia.org/wiki/Linear_difference_equation) or chapter IX of [[Sargent, 1987](/courses/Introduction-to-Quantitative-Economics/References#id210)].)

Samuelson utilized this model to investigate how specific values of the
marginal propensity to consume and the accelerator coefficient might
result in temporary _business cycles_ in national output.

Potential dynamic outcomes include:

- Gradual convergence to a steady output level
- Dampened business cycles eventually stabilizing at a constant output level
- Persistent business cycles that neither diminish nor grow

Later, we'll introduce a variation that
incorporates a random shock to the national income
identity, representing unpredictable fluctuations in aggregate demand.

This modification transforms national output into a second-order
_stochastic linear difference equation_ which, given appropriate parameter values,
produces recurring irregular business cycles.

(For information on stochastic linear difference equations, refer to chapter XI of
[[Sargent, 1987](/courses/Introduction-to-Quantitative-Economics/References#id210)].)

## Model Specifications

Let's define our variables:

- $ \{G_t\} $ represents government expenditure levels –
  initially, we'll set $ G_t = G $ for all $ t $.
- $ \{C_t\} $ represents aggregate consumption
  expenditure levels, a key endogenous variable.
- $ \{I_t\} $ represents investment rates, another crucial
  endogenous variable.
- $ \{Y_t\} $ represents national income levels, another
  endogenous variable.

- $ a $ is the marginal propensity to consume in the Keynesian
  consumption function $ C*t = a Y*{t-1} + \gamma $.
- $ b $ is the accelerator coefficient in the investment accelerator $ I*t = b (Y*{t-1} - Y\_{t-2}) $.
- $ \{\epsilon\_{t}\} $ is an IID sequence of standard normal random variables.
- $ \sigma \geq 0 $ is a volatility
  parameter — setting $ \sigma = 0 $ gives us the deterministic case
  we'll start with.

The model combines the consumption function

$$
C_t = a Y_{t-1} + \gamma \tag{22.1}
$$

with the investment accelerator

$$
I_t = b (Y_{t-1} - Y_{t-2}) \tag{22.2}
$$

and the national income identity

$$
Y_t = C_t + I_t + G_t \tag{22.3}
$$

- The parameter $ a $ represents the _marginal propensity to consume_
- equation [(22.1)](#equation-consumption) states that people consume a fraction
  $ a \in (0,1) $ of each additional dollar of income.
- The parameter $ b > 0 $ is the investment accelerator coefficient - equation
  [(22.2)](#equation-accelerator) indicates that investment increases when
  income rises and decreases when it falls.

Equations [(22.1)](#equation-consumption), [(22.2)](#equation-accelerator), and [(22.3)](#equation-income-identity)
result in the following second-order linear difference equation for national income:

$$
Y_t = (a+b) Y_{t-1} - b Y_{t-2} + (\gamma + G_t)
$$

or

$$
Y_t = \rho_1 Y_{t-1} + \rho_2 Y_{t-2} + (\gamma + G_t) \tag{22.4}
$$

where $ \rho_1 = (a+b) $ and $ \rho_2 = -b $.

To complete the model, we need two **initial conditions**.

For the model to generate time series from $ t=0 $ to $ T $, we
need initial values

$$
Y_{-1} = \bar Y_{-1}, \quad  Y_{-2} = \bar Y_{-2}
$$

We'll typically set the parameters $ (a,b) $ so that starting from
any pair of initial conditions
$ (\bar Y*{-1}, \bar Y*{-2}) $, national income $ Y_t $ converges to
a constant value as $ t $ increases.

We're interested in examining

- the temporary fluctuations in $ Y_t $ as it approaches its
  **steady state** level
- the **speed** at which it reaches a steady state level

The deterministic version of the model described so far — without
random shocks to aggregate demand — only has temporary fluctuations.

We can transform the model to one with persistent irregular
fluctuations by introducing a random shock to aggregate demand.

### Stochastic Model Variant

We create a **random** or **stochastic** version of the model by incorporating
a random process of **shocks** or **disturbances**
$ \{\sigma \epsilon_t \} $ to the right side of equation [(22.4)](#equation-second-order),
resulting in the **second-order scalar linear stochastic difference
equation**:

$$
Y_t = G_t + a (1-b) Y_{t-1} - a b Y_{t-2} + \sigma \epsilon_{t} \tag{22.5}
$$

### Mathematical Analysis of the Model

To start, let's assume $ G_t \equiv 0 $, $ \sigma = 0 $, and
$ \gamma = 0 $.

This allows us to express equation [(22.5)](#equation-second-stochastic) as

$$
Y_t = \rho_1 Y_{t-1} + \rho_2 Y_{t-2}
$$

or

$$
Y_{t+2} - \rho_1 Y_{t+1} - \rho_2 Y_t  = 0 \tag{22.6}
$$

To explore the solution properties of [(22.6)](#equation-second-stochastic2),
it's beneficial to first determine the **characteristic polynomial**
for [(22.6)](#equation-second-stochastic2):

$$
z^2 - \rho_1 z  - \rho_2 \tag{22.7}
$$

where $ z $ might be a complex number.

We aim to find the two **zeros** (or **roots**) – $ \lambda_1, \lambda_2 $ – of the characteristic polynomial.

These are two specific values of $ z $, namely $ z= \lambda_1 $ and
$ z= \lambda_2 $, such that when we substitute $ z $ with one of
these values in expression [(22.7)](#equation-polynomial),
the characteristic polynomial [(22.7)](#equation-polynomial) equals zero:

$$
z^2 - \rho_1 z  - \rho_2  = (z- \lambda_1 ) (z -\lambda_2) = 0 \tag{22.8}
$$

Equation [(22.8)](#equation-polynomial-sol) is said to **factor** the characteristic polynomial.

When the roots are complex, they appear as a complex conjugate pair.

For complex roots, it's convenient to express them in polar form:

$$
\lambda_1 =  r e^{i \omega}, \  \lambda_2 = r e^{-i \omega}
$$

where $ r $ is the _amplitude_ of the complex number and
$ \omega $ is its _angle_ or _phase_.

These can also be written as:

$$
\lambda_1 = r (cos (\omega) + i \sin (\omega))
$$

$$
\lambda_2 = r (cos (\omega) - i \sin(\omega))
$$

(For more on polar form, see
[this link](https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:complex/x9e81a4f98389efdf:complex-mul-div-polar/a/complex-number-polar-form-review))

Given **initial conditions** $ Y*{-1}, Y*{-2} $, we want to derive
a **solution** to the difference equation [(22.6)](#equation-second-stochastic2).

It can be expressed as:

$$
Y_t = \lambda_1^t c_1 + \lambda_2^t c_2
$$

where $ c_1 $ and $ c_2 $ are constants determined by the two
initial conditions and $ \rho_1, \rho_2 $.

For complex roots, the following calculations are useful.

Observe that:

$$
\begin{aligned}
Y_t & =  & c_1 (r e^{i \omega})^t + c_2 (r e^{-i \omega})^t  \\
& = & c_1 r^t e^{i\omega t} + c_2 r^t e^{-i \omega t} \\
& = &  c_1 r^t [\cos(\omega t) + i \sin(\omega t) ] + c_2 r^t [\cos(\omega t) - i \sin(\omega t) ] \\
& = & (c_1 + c_2) r^t \cos(\omega t) + i (c_1 - c_2) r^t \sin(\omega t)
\end{aligned}
$$

For $ Y_t $ to be real for all $ t $, $ c_1 + c_2 $ must be real and $ c_1 - c_2 $ must be imaginary.

This occurs only when $ c_1 $ and $ c_2 $ are complex conjugates, which can be written in polar form as:

$$
c_1 = v e^{i \theta},  \  \ c_2 = v e^{- i \theta}
$$

Thus, we can write:

$$
\begin{aligned}
Y_t & = & v e^{i \theta} r^t e^{i \omega t} + v e ^{- i \theta} r^t e^{-i \omega t} \\
& = & v r^t [ e^{i(\omega t + \theta)} + e^{-i (\omega t +\theta)}]  \\
& = & 2 v r^t  \cos (\omega t + \theta)
\end{aligned}
$$

where $ v $ and $ \theta $ are constants chosen to meet initial conditions for $ Y*{-1}, Y*{-2} $.

This formula shows that for complex roots, $ Y_t $ exhibits
oscillations with **period** $ \check p =
\frac{2 \pi}{\omega} $ and **damping factor** $ r $.

We call $ \check p $ the **period** because in this time span, the cosine wave $ \cos(\omega t + \theta) $ completes exactly one full cycle.

(Sketch a cosine function to verify this)

**Note:** Following [[Samuelson, 1939](/courses/Introduction-to-Quantitative-Economics/References#id88)], we aim to select parameters
$ a, b $ for the model such that the absolute values of the (possibly
complex) roots $ \lambda_1, \lambda_2 $ of the characteristic
polynomial are both strictly less than one:

$$
| \lambda_j | < 1 \quad \quad \text{for } j = 1,... 2
$$

**Note:** When both roots $ \lambda_1, \lambda_2 $ of the characteristic polynomial have
absolute values strictly less than one, the absolute value of the larger
one governs the rate of convergence to the steady state of the non
stochastic version of the model.

### Activities in This Lecture

We develop a function to simulate a sequence $ \{Y_t\} $ over time.

The function requires initial conditions for $ Y*{-1}, Y*{-2} $.

It verifies that $ a, b $ are set so that $ \lambda_1, \lambda_2 $ have moduli less than
one.

The function also indicates if the roots are complex, and, if so, provides their real and imaginary components.

For real roots, the function returns their values.

We utilize the function to simulate stochastic paths (when $ \sigma >0 $).

The function is designed to accept $ \{G_t\} $ paths of simple forms, such as:

- a single-time increase in $ G $ at a specific time
- a permanent increase in $ G $ starting at a certain time

We proceed to use the Samuelson multiplier-accelerator model as a framework for a simple OOP example.

The “state” influencing next period’s $ Y*{t+1} $ includes the current value $ Y_t $ and the lagged value $ Y*{t-1} $.

This requires more bookkeeping than the Solow model class definition.

We use the Samuelson model to demonstrate how to incrementally add features to a class.

We aim to have a method in the class that automatically generates a simulation, either non-stochastic ($ \sigma=0 $) or stochastic ($ \sigma > 0 $).

We also demonstrate how to map the Samuelson model to a `LinearStateSpace` class instance.

A `LinearStateSpace` instance can perform tasks similar to those done with our custom function and class.

For instance, the eigenvalues of the matrix $ A $ used to create the `LinearStateSpace` class instance for the Samuelson model match the roots of the characteristic polynomial [(22.7)](#equation-polynomial) for the Samuelson model.

The matrix $ A $ in the linear state space system, assuming constant government expenditures $ G $, is:

$$
A = \begin{bmatrix} 1 & 0 & 0 \cr
\gamma + G & \rho_1 & \rho_2 \cr
0 & 1 & 0 \end{bmatrix}
$$

## Implementation

We’ll begin by illustrating a graph from page 189 of [[Sargent, 1987](/courses/Introduction-to-Quantitative-Economics/References#id210)]

```python
def param_plot():

    """This function creates the graph on page 189 of
    Sargent Macroeconomic Theory, second edition, 1987.
    """

    fig, ax = plt.subplots(figsize=(10, 6))
    ax.set_aspect('equal')

    # Set axis
    xmin, ymin = -3, -2
    xmax, ymax = -xmin, -ymin
    plt.axis([xmin, xmax, ymin, ymax])

    # Set axis labels
    ax.set(xticks=[], yticks=[])
    ax.set_xlabel(r'$\rho_2$', fontsize=16)
    ax.xaxis.set_label_position('top')
    ax.set_ylabel(r'$\rho_1$', rotation=0, fontsize=16)
    ax.yaxis.set_label_position('right')

    # Draw (t1, t2) points
    ρ1 = np.linspace(-2, 2, 100)
    ax.plot(ρ1, -abs(ρ1) + 1, c='black')
    ax.plot(ρ1, np.full_like(ρ1, -1), c='black')
    ax.plot(ρ1, -(ρ1**2 / 4), c='black')

    # Turn normal axes off
    for spine in ['left', 'bottom', 'top', 'right']:
        ax.spines[spine].set_visible(False)

    # Add arrows to represent axes
    axes_arrows = {'arrowstyle': '<|-|>', 'lw': 1.3}
    ax.annotate('', xy=(xmin, 0), xytext=(xmax, 0), arrowprops=axes_arrows)
    ax.annotate('', xy=(0, ymin), xytext=(0, ymax), arrowprops=axes_arrows)

    # Annotate the plot with equations
    plot_arrowsl = {'arrowstyle': '-|>', 'connectionstyle': "arc3, rad=-0.2"}
    plot_arrowsr = {'arrowstyle': '-|>', 'connectionstyle': "arc3, rad=0.2"}
    ax.annotate(r'$\rho_1 + \rho_2 < 1$', xy=(0.5, 0.3), xytext=(0.8, 0.6),
                arrowprops=plot_arrowsr, fontsize='12')
    ax.annotate(r'$\rho_1 + \rho_2 = 1$', xy=(0.38, 0.6), xytext=(0.6, 0.8),
                arrowprops=plot_arrowsr, fontsize='12')
    ax.annotate(r'$\rho_2 < 1 + \rho_1$', xy=(-0.5, 0.3), xytext=(-1.3, 0.6),
                arrowprops=plot_arrowsl, fontsize='12')
    ax.annotate(r'$\rho_2 = 1 + \rho_1$', xy=(-0.38, 0.6), xytext=(-1, 0.8),
                arrowprops=plot_arrowsl, fontsize='12')
    ax.annotate(r'$\rho_2 = -1$', xy=(1.5, -1), xytext=(1.8, -1.3),
                arrowprops=plot_arrowsl, fontsize='12')
    ax.annotate(r'${\rho_1}^2 + 4\rho_2 = 0$', xy=(1.15, -0.35),
                xytext=(1.5, -0.3), arrowprops=plot_arrowsr, fontsize='12')
    ax.annotate(r'${\rho_1}^2 + 4\rho_2 < 0$', xy=(1.4, -0.7),
                xytext=(1.8, -0.6), arrowprops=plot_arrowsr, fontsize='12')

    # Label categories of solutions
    ax.text(1.5, 1, 'Explosive\n growth', ha='center', fontsize=16)
    ax.text(-1.5, 1, 'Explosive\n oscillations', ha='center', fontsize=16)
    ax.text(0.05, -1.5, 'Explosive oscillations', ha='center', fontsize=16)
    ax.text(0.09, -0.5, 'Damped oscillations', ha='center', fontsize=16)

    # Add small marker to y-axis
    ax.axhline(y=1.005, xmin=0.495, xmax=0.505, c='black')
    ax.text(-0.12, -1.12, '-1', fontsize=10)
    ax.text(-0.12, 0.98, '1', fontsize=10)

    return fig

param_plot()
plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_14_0.png)
</div>

The graph illustrates regions where the $ (\lambda_1, \lambda_2) $
root pairs, as implied by the $ (\rho_1 = (a+b), \rho_2 = - b) $
difference equation parameters in the Samuelson model, exhibit:

- Complex $ (\lambda_1, \lambda_2) $ with modulus less than
  $ 1 $ - resulting in damped oscillations in the $ \{Y_t\} $ sequence.
- Real $ (\lambda_1, \lambda_2) $, with one strictly
  greater than $ 1 $ - leading to explosive growth.
- Real $ (\lambda_1, \lambda_2) $, with one strictly
  less than $ -1 $ - causing explosive oscillations.
- Real $ (\lambda_1, \lambda_2) $, both less than
$ 1 $ in absolute value - resulting in smooth
  convergence to the steady state without cycles.

Later, we’ll present the graph with a red mark indicating the specific
point determined by the $ (a,b) $ settings.

### Function for Characteristic Polynomial Implications

```python
def categorize_solution(ρ1, ρ2):

    """This function takes values of ρ1 and ρ2 and uses them
    to classify the type of solution
    """

    discriminant = ρ1 ** 2 + 4 * ρ2
    if ρ2 > 1 + ρ1 or ρ2 < -1:
        print('Explosive oscillations')
    elif ρ1 + ρ2 > 1:
        print('Explosive growth')
    elif discriminant < 0:
        print('Roots are complex with modulus less than one; \
therefore damped oscillations')
    else:
        print('Roots are real and absolute values are less than one; \
therefore get smooth convergence to a steady state')
```

```python
### Test the categorize_solution function

categorize_solution(1.3, -.4)
```

    Roots are real and absolute values are less than one; therefore get smooth convergence to a steady state

### Function for Plotting Paths

A useful function for our subsequent work is

```python
def plot_y(function=None):

    """Function plots path of Y_t"""

    plt.subplots(figsize=(10, 6))
    plt.plot(function)
    plt.xlabel('Time $t$')
    plt.ylabel('$Y_t$', rotation=0)
    plt.grid()
    plt.show()
```

### Manual Root Calculations

The following function calculates roots of the characteristic polynomial
using basic algebra.

(We’ll explore other methods for root calculation later)

The function also plots a $ Y_t $ starting from initial conditions
that we specify

```python
# This is a 'manual' method

def y_nonstochastic(y_0=100, y_1=80, α=.92, β=.5, γ=10, n=80):

    """Takes values of parameters and computes the roots of characteristic
    polynomial. It tells whether they are real or complex and whether they
    are less than unity in absolute value.It also computes a simulation of
    length n starting from the two given initial conditions for national
    income
    """

    roots = []

    ρ1 = α + β
    ρ2 = -β

    print(f'ρ_1 is {ρ1}')
    print(f'ρ_2 is {ρ2}')

    discriminant = ρ1 ** 2 + 4 * ρ2

    if discriminant == 0:
        roots.append(-ρ1 / 2)
        print('Single real root: ')
        print(''.join(str(roots)))
    elif discriminant > 0:
        roots.append((-ρ1 + sqrt(discriminant).real) / 2)
        roots.append((-ρ1 - sqrt(discriminant).real) / 2)
        print('Two real roots: ')
        print(''.join(str(roots)))
    else:
        roots.append((-ρ1 + sqrt(discriminant)) / 2)
        roots.append((-ρ1 - sqrt(discriminant)) / 2)
        print('Two complex roots: ')
        print(''.join(str(roots)))

    if all(abs(root) < 1 for root in roots):
        print('Absolute values of roots are less than one')
    else:
        print('Absolute values of roots are not less than one')

    def transition(x, t): return ρ1 * x[t - 1] + ρ2 * x[t - 2] + γ

    y_t = [y_0, y_1]

    for t in range(2, n):
        y_t.append(transition(y_t, t))

    return y_t

plot_y(y_nonstochastic())
```

    ρ_1 is 1.42
    ρ_2 is -0.5
    Two real roots:
    [-0.6459687576256715, -0.7740312423743284]
    Absolute values of roots are less than one

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_22_1.png)
</div>

### Reverse-Engineering Parameters for Damped Cycles

The next code cell takes as inputs the modulus $ r $ and
phase $ \phi $ of a complex conjugate pair in polar form

$$
\lambda_1 = r \exp(i \phi), \quad \lambda_2 = r \exp(- i \phi)
$$

- The code assumes these complex numbers are the roots of the
  characteristic polynomial
- It then reverse-engineers $ (a,b) $ and $ (\rho_1, \rho_2) $,
  pairs to generate those roots

```python
### code to reverse-engineer a cycle
### y_t = r^t (c_1 cos(ϕ t) + c2 sin(ϕ t))
###

def f(r, ϕ):
    """
    Takes modulus r and angle ϕ of complex number r exp(j ϕ)
    and creates ρ1 and ρ2 of characteristic polynomial for which
    r exp(j ϕ) and r exp(- j ϕ) are complex roots.

    Returns the multiplier coefficient a and the accelerator coefficient b
    that verifies those roots.
    """
    g1 = cmath.rect(r, ϕ)  # Generate two complex roots
    g2 = cmath.rect(r, -ϕ)
    ρ1 = g1 + g2           # Implied ρ1, ρ2
    ρ2 = -g1 * g2
    b = -ρ2                # Reverse-engineer a and b that validate these
    a = ρ1 - b
    return ρ1, ρ2, a, b

## Now let's use the function in an example
## Here are the example parameters

r = .95
period = 10                # Length of cycle in units of time
ϕ = 2 * math.pi/period

## Apply the function

ρ1, ρ2, a, b = f(r, ϕ)

print(f"a, b = {a}, {b}")
print(f"ρ1, ρ2 = {ρ1}, {ρ2}")
```

    a, b = (0.6346322893124001-2.1528634180704965e-17j), (0.9024999999999999+2.1528634180704965e-17j)
    ρ1, ρ2 = (1.5371322893124+0j), (-0.9024999999999999-2.1528634180704965e-17j)

```python
## Print the real components of ρ1 and ρ2

ρ1 = ρ1.real
ρ2 = ρ2.real

ρ1, ρ2
```

    (1.5371322893124, -0.9024999999999999)

### Root Finding with Numpy

Here, we utilize numpy to compute the roots of the characteristic
polynomial

```python
r1, r2 = np.roots([1, -ρ1, -ρ2])

p1 = cmath.polar(r1)
p2 = cmath.polar(r2)

print(f"r, ϕ = {r}, {ϕ}")
print(f"p1, p2 = {p1}, {p2}")
# print(f"g1, g2 = {g1}, {g2}")

print(f"a, b = {a}, {b}")
print(f"ρ1, ρ2 = {ρ1}, {ρ2}")
```

    r, ϕ = 0.95, 0.6283185307179586
    p1, p2 = (0.95, 0.6283185307179586), (0.95, -0.6283185307179586)
    a, b = (0.6346322893124001-2.1528634180704965e-17j), (0.9024999999999999+2.1528634180704965e-17j)
    ρ1, ρ2 = 1.5371322893124, -0.9024999999999999

```python
##=== This method uses numpy to calculate roots ===#


def y_nonstochastic(y_0=100, y_1=80, α=.9, β=.8, γ=10, n=80):

    """ Rather than computing the roots of the characteristic
    polynomial by hand as we did earlier, this function
    enlists numpy to do the work for us
    """

    # Useful constants
    ρ1 = α + β
    ρ2 = -β

    categorize_solution(ρ1, ρ2)

    # Find roots of polynomial
    roots = np.roots([1, -ρ1, -ρ2])
    print(f'Roots are {roots}')

    # Check if real or complex
    if all(isinstance(root, complex) for root in roots):
        print('Roots are complex')
    else:
        print('Roots are real')

    # Check if roots are less than one
    if all(abs(root) < 1 for root in roots):
        print('Roots are less than one')
    else:
        print('Roots are not less than one')

    # Define transition equation
    def transition(x, t): return ρ1 * x[t - 1] + ρ2 * x[t - 2] + γ

    # Set initial conditions
    y_t = [y_0, y_1]

    # Generate y_t series
    for t in range(2, n):
        y_t.append(transition(y_t, t))

    return y_t

plot_y(y_nonstochastic())
```

    Roots are complex with modulus less than one; therefore damped oscillations
    Roots are [0.85+0.27838822j 0.85-0.27838822j]
    Roots are complex
    Roots are less than one

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_28_1.png)
</div>

### Reverse-Engineered Complex Roots: Example

The next cell examines the implications of reverse-engineered complex
roots.

We’ll generate an **undamped** cycle with a period of 10

```python
r = 1   # Generates undamped, nonexplosive cycles

period = 10   # Length of cycle in units of time
ϕ = 2 * math.pi/period

## Apply the reverse-engineering function f

ρ1, ρ2, a, b = f(r, ϕ)

# Drop the imaginary part so that it is a valid input into y_nonstochastic
a = a.real
b = b.real

print(f"a, b = {a}, {b}")

ytemp = y_nonstochastic(α=a, β=b, y_0=20, y_1=30)
plot_y(ytemp)
```

    a, b = 0.6180339887498949, 1.0
    Roots are complex with modulus less than one; therefore damped oscillations
    Roots are [0.80901699+0.58778525j 0.80901699-0.58778525j]
    Roots are complex
    Roots are not less than one

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_30_1.png)
</div>

### Digression: Using Sympy for Root Finding

We can also employ sympy to derive analytic expressions for the roots

```python
init_printing()

r1 = Symbol("ρ_1")
r2 = Symbol("ρ_2")
z = Symbol("z")

sympy.solve(z**2 - r1*z - r2, z)
```

$\displaystyle \left[ \frac{ρ_{1}}{2} - \frac{\sqrt{ρ_{1}^{2} + 4 ρ_{2}}}{2}, \  \frac{ρ_{1}}{2} + \frac{\sqrt{ρ_{1}^{2} + 4 ρ_{2}}}{2}\right]$

```python
a = Symbol("α")
b = Symbol("β")
r1 = a + b
r2 = -b

sympy.solve(z**2 - r1*z - r2, z)
```

$\displaystyle \left[ \frac{α}{2} + \frac{β}{2} - \frac{\sqrt{α^{2} + 2 α β + β^{2} - 4 β}}{2}, \  \frac{α}{2} + \frac{β}{2} + \frac{\sqrt{α^{2} + 2 α β + β^{2} - 4 β}}{2}\right]$

## Stochastic Shocks

We’ll now develop code to simulate the stochastic version of the
model that arises when a random shock process is added to aggregate
demand

```python
def y_stochastic(y_0=0, y_1=0, α=0.8, β=0.2, γ=10, n=100, σ=5):

    """This function takes parameters of a stochastic version of
    the model and proceeds to analyze the roots of the characteristic
    polynomial and also generate a simulation.
    """

    # Useful constants
    ρ1 = α + β
    ρ2 = -β

    # Categorize solution
    categorize_solution(ρ1, ρ2)

    # Find roots of polynomial
    roots = np.roots([1, -ρ1, -ρ2])
    print(roots)

    # Check if real or complex
    if all(isinstance(root, complex) for root in roots):
        print('Roots are complex')
    else:
        print('Roots are real')

    # Check if roots are less than one
    if all(abs(root) < 1 for root in roots):
        print('Roots are less than one')
    else:
        print('Roots are not less than one')

    # Generate shocks
    ϵ = np.random.normal(0, 1, n)

    # Define transition equation
    def transition(x, t): return ρ1 * \
        x[t - 1] + ρ2 * x[t - 2] + γ + σ * ϵ[t]

    # Set initial conditions
    y_t = [y_0, y_1]

    # Generate y_t series
    for t in range(2, n):
        y_t.append(transition(y_t, t))

    return y_t

plot_y(y_stochastic())
```

    Roots are real and absolute values are less than one; therefore get smooth convergence to a steady state
    [0.7236068 0.2763932]
    Roots are real
    Roots are less than one

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_35_1.png)
</div>

Let’s conduct a simulation with shocks and complex roots in the characteristic polynomial

```python
r = .97

period = 10   #  Length of cycle in units of time
ϕ = 2 * math.pi/period

### Apply the  reverse-engineering function f

ρ1, ρ2, a, b = f(r, ϕ)

# Drop the imaginary part so that it is a valid input into y_nonstochastic
a = a.real
b = b.real

print(f"a, b = {a}, {b}")
plot_y(y_stochastic(y_0=40, y_1 = 42, α=a, β=b, σ=2, n=100))
```

    a, b = 0.6285929690873979, 0.9409000000000001
    Roots are complex with modulus less than one; therefore damped oscillations
    [0.78474648+0.57015169j 0.78474648-0.57015169j]
    Roots are complex
    Roots are less than one

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_37_1.png)
</div>

## Government Spending

This function calculates the response to either a permanent or one-time increase
in government expenditures

```python
def y_stochastic_g(y_0=20,
                   y_1=20,
                   α=0.8,
                   β=0.2,
                   γ=10,
                   n=100,
                   σ=2,
                   g=0,
                   g_t=0,
                   duration='permanent'):

    """This program computes a response to a permanent increase
    in government expenditures that occurs at time 20
    """

    # Useful constants
    ρ1 = α + β
    ρ2 = -β

    # Categorize solution
    categorize_solution(ρ1, ρ2)

    # Find roots of polynomial
    roots = np.roots([1, -ρ1, -ρ2])
    print(roots)

    # Check if real or complex
    if all(isinstance(root, complex) for root in roots):
        print('Roots are complex')
    else:
        print('Roots are real')

    # Check if roots are less than one
    if all(abs(root) < 1 for root in roots):
        print('Roots are less than one')
    else:
        print('Roots are not less than one')

    # Generate shocks
    ϵ = np.random.normal(0, 1, n)

    def transition(x, t, g):

        # Non-stochastic - separated to avoid generating random series
        # when not needed
        if σ == 0:
            return ρ1 * x[t - 1] + ρ2 * x[t - 2] + γ + g

        # Stochastic
        else:
            ϵ = np.random.normal(0, 1, n)
            return ρ1 * x[t - 1] + ρ2 * x[t - 2] + γ + g + σ * ϵ[t]

    # Create list and set initial conditions
    y_t = [y_0, y_1]

    # Generate y_t series
    for t in range(2, n):

        # No government spending
        if g == 0:
            y_t.append(transition(y_t, t))

        # Government spending (no shock)
        elif g != 0 and duration == None:
            y_t.append(transition(y_t, t))

        # Permanent government spending shock
        elif duration == 'permanent':
            if t < g_t:
                y_t.append(transition(y_t, t, g=0))
            else:
                y_t.append(transition(y_t, t, g=g))

        # One-off government spending shock
        elif duration == 'one-off':
            if t == g_t:
                y_t.append(transition(y_t, t, g=g))
            else:
                y_t.append(transition(y_t, t, g=0))
    return y_t
```

A permanent government spending shock can be simulated as follows

```python
plot_y(y_stochastic_g(g=10, g_t=20, duration='permanent'))
```

    Roots are real and absolute values are less than one; therefore get smooth convergence to a steady state
    [0.7236068 0.2763932]
    Roots are real
    Roots are less than one

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_41_1.png)
</div>

We can also observe the response to a one-time jump in government expenditures

```python
plot_y(y_stochastic_g(g=500, g_t=50, duration='one-off'))
```

    Roots are real and absolute values are less than one; therefore get smooth convergence to a steady state
    [0.7236068 0.2763932]
    Roots are real
    Roots are less than one

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_43_1.png)
</div>

## Wrapping Everything Into a Class

So far, we have written functions to perform the tasks.

Now, we’ll write a Python class named `Samuelson`
for the Samuelson model

```python
class Samuelson():

    """This class represents the Samuelson model, otherwise known as the
    multiple-accelerator model. The model combines the Keynesian multiplier
    with the accelerator theory of investment.

    The path of output is governed by a linear second-order difference equation

    .. math::

        Y_t =  + \alpha (1 + \beta) Y_{t-1} - \alpha \beta Y_{t-2}

    Parameters
    ----------
    y_0 : scalar
        Initial condition for Y_0
    y_1 : scalar
        Initial condition for Y_1
    α : scalar
        Marginal propensity to consume
    β : scalar
        Accelerator coefficient
    n : int
        Number of iterations
    σ : scalar
        Volatility parameter. It must be greater than or equal to 0. Set
        equal to 0 for a non-stochastic model.
    g : scalar
        Government spending shock
    g_t : int
        Time at which government spending shock occurs. Must be specified
        when duration != None.
    duration : {None, 'permanent', 'one-off'}
        Specifies type of government spending shock. If none, government
        spending equal to g for all t.

    """

    def __init__(self,
                 y_0=100,
                 y_1=50,
                 α=1.3,
                 β=0.2,
                 γ=10,
                 n=100,
                 σ=0,
                 g=0,
                 g_t=0,
                 duration=None):

        self.y_0, self.y_1, self.α, self.β = y_0, y_1, α, β
        self.n, self.g, self.g_t, self.duration = n, g, g_t, duration
        self.γ, self.σ = γ, σ
        self.ρ1 = α + β
        self.ρ2 = -β
        self.roots = np.roots([1, -self.ρ1, -self.ρ2])

    def root_type(self):
        if all(isinstance(root, complex) for root in self.roots):
            return 'Complex conjugate'
        elif len(self.roots) > 1:
            return 'Double real'
        else:
            return 'Single real'

    def root_less_than_one(self):
        if all(abs(root) < 1 for root in self.roots):
            return True

    def solution_type(self):
        ρ1, ρ2 = self.ρ1, self.ρ2
        discriminant = ρ1 ** 2 + 4 * ρ2
        if ρ2 >= 1 + ρ1 or ρ2 <= -1:
            return 'Explosive oscillations'
        elif ρ1 + ρ2 >= 1:
            return 'Explosive growth'
        elif discriminant < 0:
            return 'Damped oscillations'
        else:
            return 'Steady state'

    def _transition(self, x, t, g):

        # Non-stochastic - separated to avoid generating random series
        # when not needed
        if self.σ == 0:
            return self.ρ1 * x[t - 1] + self.ρ2 * x[t - 2] + self.γ + g

        # Stochastic
        else:
            ϵ = np.random.normal(0, 1, self.n)
            return self.ρ1 * x[t - 1] + self.ρ2 * x[t - 2] + self.γ + g \
                + self.σ * ϵ[t]

    def generate_series(self):

        # Create list and set initial conditions
        y_t = [self.y_0, self.y_1]

        # Generate y_t series
        for t in range(2, self.n):

            # No government spending
            if self.g == 0:
                y_t.append(self._transition(y_t, t))

            # Government spending (no shock)
            elif self.g != 0 and self.duration == None:
                y_t.append(self._transition(y_t, t))

            # Permanent government spending shock
            elif self.duration == 'permanent':
                if t < self.g_t:
                    y_t.append(self._transition(y_t, t, g=0))
                else:
                    y_t.append(self._transition(y_t, t, g=self.g))

            # One-off government spending shock
            elif self.duration == 'one-off':
                if t == self.g_t:
                    y_t.append(self._transition(y_t, t, g=self.g))
                else:
                    y_t.append(self._transition(y_t, t, g=0))
        return y_t

    def summary(self):
        print('Summary\n' + '-' * 50)
        print(f'Root type: {self.root_type()}')
        print(f'Solution type: {self.solution_type()}')
        print(f'Roots: {str(self.roots)}')

        if self.root_less_than_one() == True:
            print('Absolute value of roots is less than one')
        else:
            print('Absolute value of roots is not less than one')

        if self.σ > 0:
            print('Stochastic series with σ = ' + str(self.σ))
        else:
            print('Non-stochastic series')

        if self.g != 0:
            print('Government spending equal to ' + str(self.g))

        if self.duration != None:
            print(self.duration.capitalize() +
                  ' government spending shock at t = ' + str(self.g_t))

    def plot(self):
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(self.generate_series())
        ax.set(xlabel='Iteration', xlim=(0, self.n))
        ax.set_ylabel('$Y_t$', rotation=0)
        ax.grid()

        # Add parameter values to plot
        paramstr = f'$\\alpha={self.α:.2f}$ \n $\\beta={self.β:.2f}$ \n \
        $\\gamma={self.γ:.2f}$ \n $\\sigma={self.σ:.2f}$ \n \
        $\\rho_1={self.ρ1:.2f}$ \n $\\rho_2={self.ρ2:.2f}$'
        props = dict(fc='white', pad=10, alpha=0.5)
        ax.text(0.87, 0.05, paramstr, transform=ax.transAxes,
                fontsize=12, bbox=props, va='bottom')

        return fig

    def param_plot(self):

        # Uses the param_plot() function defined earlier (it is then able
        # to be used standalone or as part of the model)

        fig = param_plot()
        ax = fig.gca()

        # Add λ values to legend
        for i, root in enumerate(self.roots):
            if isinstance(root, complex):
                # Need to fill operator for positive as string is split apart
                operator = ['+', '']
                label = rf'$\lambda_{i+1} = {sam.roots[i].real:.2f} {operator[i]} {sam.roots[i].imag:.2f}i$'
            else:
                label = rf'$\lambda_{i+1} = {sam.roots[i].real:.2f}$'
            ax.scatter(0, 0, 0, label=label) # dummy to add to legend

        # Add ρ pair to plot
        ax.scatter(self.ρ1, self.ρ2, 100, 'red', '+',
            label=r'$(\ \rho_1, \ \rho_2 \ )$', zorder=5)

        plt.legend(fontsize=12, loc=3)

        return fig
```

### Demonstration of Samuelson Class

Now, we’ll apply our Samuelson class to an example

```python
sam = Samuelson(α=0.8, β=0.5, σ=2, g=10, g_t=20, duration='permanent')
sam.summary()
```

    Summary
    --------------------------------------------------
    Root type: Complex conjugate
    Solution type: Damped oscillations
    Roots: [0.65+0.27838822j 0.65-0.27838822j]
    Absolute value of roots is less than one
    Stochastic series with σ = 2
    Government spending equal to 10
    Permanent government spending shock at t = 20

```python
sam.plot()
plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_48_0.png)
</div>

### Using the Graph

We’ll utilize our graph to display the root locations and how their positions
align with the behavior of the previously graphed path.

The red $ + $ sign indicates the root locations

```python
sam.param_plot()
plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_50_0.png)
</div>

## Using the LinearStateSpace Class

We can employ the [QuantEcon.py](http://quantecon.org/quantecon-py)
[LinearStateSpace](https://github.com/QuantEcon/QuantEcon.py/blob/master/quantecon/lss.py) class to perform
many tasks we have manually executed above.

Here’s how to map the Samuelson model to a
`LinearStateSpace` class instance

```python
"""This script maps the Samuelson model in the the
``LinearStateSpace`` class
"""
α = 0.8
β = 0.9
ρ1 = α + β
ρ2 = -β
γ = 10
σ = 1
g = 10
n = 100

A = [[1,        0,      0],
     [γ + g,   ρ1,     ρ2],
     [0,        1,      0]]

G = [[γ + g, ρ1,   ρ2],         # this is Y_{t+1}
     [γ,      α,    0],         # this is C_{t+1}
     [0,      β,   -β]]         # this is I_{t+1}

μ_0 = [1, 100, 50]
C = np.zeros((3,1))
C[1] = σ # stochastic

sam_t = LinearStateSpace(A, C, G, mu_0=μ_0)

x, y = sam_t.simulate(ts_length=n)

fig, axes = plt.subplots(3, 1, sharex=True, figsize=(12, 8))
titles = ['Output ($Y_t$)', 'Consumption ($C_t$)', 'Investment ($I_t$)']
colors = ['darkblue', 'red', 'purple']
for ax, series, title, color in zip(axes, y, titles, colors):
    ax.plot(series, color=color)
    ax.set(title=title, xlim=(0, n))
    ax.grid()

axes[-1].set_xlabel('Iteration')

plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_52_0.png)
</div>

### Additional Methods in the `LinearStateSpace` Class

Let’s plot **impulse response functions** for the Samuelson model instance using a method in the `LinearStateSpace` class

```python
imres = sam_t.impulse_response()
imres = np.asarray(imres)
y1 = imres[:, :, 0]
y2 = imres[:, :, 1]
y1.shape
```

$\displaystyle \left( 2, \  6, \  1\right)$

Now, let’s compute the zeros of the characteristic polynomial by simply
calculating the eigenvalues of $ A $

```python
A = np.asarray(A)
w, v = np.linalg.eig(A)
print(w)
```

    [0.85+0.42130749j 0.85-0.42130749j 1.  +0.j        ]

### Inheriting Methods from `LinearStateSpace`

We could also create a subclass of `LinearStateSpace` (inheriting all its
methods and attributes) to add more functionalities

```python
class SamuelsonLSS(LinearStateSpace):

    """
    This subclass creates a Samuelson multiplier-accelerator model
    as a linear state space system.
    """
    def __init__(self,
                 y_0=100,
                 y_1=50,
                 α=0.8,
                 β=0.9,
                 γ=10,
                 σ=1,
                 g=10):

        self.α, self.β = α, β
        self.y_0, self.y_1, self.g = y_0, y_1, g
        self.γ, self.σ = γ, σ

        # Define intial conditions
        self.μ_0 = [1, y_0, y_1]

        self.ρ1 = α + β
        self.ρ2 = -β

        # Define transition matrix
        self.A = [[1,                 0,         0],
                  [γ + g,       self.ρ1,   self.ρ2],
                  [0,                 1,         0]]

        # Define output matrix
        self.G = [[γ + g, self.ρ1, self.ρ2],         # this is Y_{t+1}
                  [γ,           α,       0],         # this is C_{t+1}
                  [0,           β,      -β]]         # this is I_{t+1}

        self.C = np.zeros((3, 1))
        self.C[1] = σ  # stochastic

        # Initialize LSS with parameters from Samuelson model
        LinearStateSpace.__init__(self, self.A, self.C, self.G, mu_0=self.μ_0)

    def plot_simulation(self, ts_length=100, stationary=True):

        # Temporarily store original parameters
        temp_mu = self.mu_0
        temp_Sigma = self.Sigma_0

        # Set distribution parameters equal to their stationary
        # values for simulation
        if stationary == True:
            try:
                self.mu_x, self.mu_y, self.Sigma_x, self.Sigma_y, self.Sigma_yx = \
                    self.stationary_distributions()
                self.mu_0 = self.mu_x
                self.Sigma_0 = self.Sigma_x
            # Exception where no convergence achieved when
            #calculating stationary distributions
            except ValueError:
                print('Stationary distribution does not exist')

        x, y = self.simulate(ts_length)

        fig, axes = plt.subplots(3, 1, sharex=True, figsize=(12, 8))
        titles = ['Output ($Y_t$)', 'Consumption ($C_t$)', 'Investment ($I_t$)']
        colors = ['darkblue', 'red', 'purple']
        for ax, series, title, color in zip(axes, y, titles, colors):
            ax.plot(series, color=color)
            ax.set(title=title, xlim=(0, n))
            ax.grid()

        axes[-1].set_xlabel('Iteration')

        # Reset distribution parameters to their initial values
        self.mu_0 = temp_mu
        self.Sigma_0 = temp_Sigma

        return fig

    def plot_irf(self, j=5):

        x, y = self.impulse_response(j)

        # Reshape into 3 x j matrix for plotting purposes
        yimf = np.array(y).flatten().reshape(j+1, 3).T

        fig, axes = plt.subplots(3, 1, sharex=True, figsize=(12, 8))
        labels = ['$Y_t$', '$C_t$', '$I_t$']
        colors = ['darkblue', 'red', 'purple']
        for ax, series, label, color in zip(axes, yimf, labels, colors):
            ax.plot(series, color=color)
            ax.set(xlim=(0, j))
            ax.set_ylabel(label, rotation=0, fontsize=14, labelpad=10)
            ax.grid()

        axes[0].set_title('Impulse Response Functions')
        axes[-1].set_xlabel('Iteration')

        return fig

    def multipliers(self, j=5):
        x, y = self.impulse_response(j)
        return np.sum(np.array(y).flatten().reshape(j+1, 3), axis=0)
```

### Illustrations

Let’s demonstrate how to use the `SamuelsonLSS`

```python
samlss = SamuelsonLSS()
```

```python
samlss.plot_simulation(100, stationary=False)
plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_61_0.png)
</div>

```python
samlss.plot_simulation(100, stationary=True)
plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_62_0.png)
</div>

```python
samlss.plot_irf(100)
plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_63_0.png)
</div>

```python
samlss.multipliers()
```

    array([7.414389, 6.835896, 0.578493])

## Pure Multiplier Model

Let’s eliminate the accelerator by setting $ b=0 $ to obtain a pure
multiplier model

- The absence of cycles provides insight into why Samuelson included the
  accelerator

```python
pure_multiplier = SamuelsonLSS(α=0.95, β=0)
```

```python
pure_multiplier.plot_simulation()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_67_0.png)
</div>

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_67_1.png)
</div>

```python
pure_multiplier = SamuelsonLSS(α=0.8, β=0)
```

```python
pure_multiplier.plot_simulation()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_69_0.png)
</div>

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_69_1.png)
</div>

```python
pure_multiplier.plot_irf(100)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_70_0.png)
</div>

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/22.%20Samuelson%20Multiplier-Accelerator_files/22.%20Samuelson%20Multiplier-Accelerator_70_1.png)
</div>

## Summary

In this lecture, we developed functions and classes to represent non-stochastic and
stochastic versions of the Samuelson (1939) multiplier-accelerator model, as described
in [[Samuelson, 1939](/courses/Introduction-to-Quantitative-Economics/References#id88)].

We observed that different parameter values resulted in different output paths, which
could be stationary, explosive, or oscillating.

We also represented the model using the [QuantEcon.py](http://quantecon.org/quantecon-py)
[LinearStateSpace](https://github.com/QuantEcon/QuantEcon.py/blob/master/quantecon/lss.py) class.
