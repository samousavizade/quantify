---
title: Modeling COVID 19
draft: false
summary: test
---

import TOCInline from 'pliny/ui/TOCInline';

<TOCInline toc={props.toc} asDisclosure />

# Investigating COVID-19 Through Mathematical Modeling

## Overview

This Python script is a quantitative infectious disease modeling tool that applies Andrew Atkeson's work to analyze the COVID-19 pandemic using an SIR (Susceptible-Infected-Removed) model. The script introduces economists to the use of ordinary differential equations in simulating disease spread dynamics, with a focus on how social distancing affects infection rates. While the default parameters are set for the US, they can be customized for other countries as well.

```python
import matplotlib.pyplot as plt
plt.rcParams["figure.figsize"] = (11, 5)  #set default figure size
import numpy as np
from numpy import exp
```

We'll utilize SciPy's `odeint` function for numerically solving differential equations.

```python
from scipy.integrate import odeint
```

This function utilizes pre-compiled code from the Fortran-based ODEPACK library.

## Explanation of the SIR Model

The model categorizes the population into four states: susceptible, exposed, infected, and removed ($S$, $E$, $I$, $R$). Key points include:

- Removed individuals comprise both those who have recovered and those who have passed away.

- Recovery is assumed to provide immunity.

- Exposed individuals are not yet infectious.

### Progression of the Disease

The infection follows a sequence $S \rightarrow E \rightarrow I \rightarrow R$. With a positive transmission rate and initial infections, the entire population eventually becomes infected. The model primarily focuses on:

1. The number of active infections at any given time (indicating potential healthcare system stress)

2. The delay in peak caseload (potentially allowing time for vaccine development)

The system dynamics are described by these differential equations:

$$

\begin{aligned}

\dot s(t) & = - \beta(t) \, s(t) \, i(t)

\\

\dot e(t) & = \beta(t) \, s(t) \, i(t) - σ e(t)

\\

\dot i(t) & = σ e(t) - γ i(t)

\end{aligned} \tag{1.1}


$$

Where:

- $β(t)$ is the transmission rate

- $σ$ is the infection rate

- $γ$ is the recovery rate

- The dot notation represents time derivatives

The removed fraction $r = 1 - s - e - i$, and $c = i + r$ represents the cumulative caseload.

In vector form, the system is expressed as:

$$

\dot x = F(x, t), \qquad x := (s, e, i) \tag{1.2}


$$

### Model Parameters

Fixed biological parameters:

- $\sigma = \frac{1}{5.2}$ (average incubation period of 5.2 days)

- $\gamma = \frac{1}{18}$ (average illness duration of 18 days)

The transmission rate is defined as:

- $\beta(t) := R(t) \times \gamma$, where $R(t)$ is the effective reproduction number at time $t$.

## Model Implementation

Initially, we configure the population count to align with that of the United States.

```python
pop_size = 3.3e8
```

Next, we establish the necessary parameters according to our previous discussion.

```python
γ = 1 / 18
σ = 1 / 5.2
```

Now, let's define a function that corresponds to the expression described in equation 1.2.

```python
def F(x, t, R0=1.6):
    """
    Time derivative of the state vector.

        * x is the state vector (array_like)
        * t is time (scalar)
        * R0 is the effective transmission rate, defaulting to a constant

    """
    s, e, i = x

    # New exposure of susceptibles
    β = R0(t) * γ if callable(R0) else R0 * γ
    ne = β * s * i

    # Time derivatives
    ds = - ne
    de = ne - σ * e
    di = σ * e - γ * i

    return ds, de, di
```

Note that `R0` may be either a fixed value or a variable that changes over time.

We establish the starting conditions as follows:

```python
# initial conditions of s, e, i
i_0 = 1e-7
e_0 = 4 * i_0
s_0 = 1 - i_0 - e_0
```

The Initial Condition Vector Is:

(Note: I've kept the same formatting as your original markdown code, but simply rephrased the sentence)

```python
x_0 = s_0, e_0, i_0
```

We utilize `odeint` to computationally resolve the temporal progression at a series of timestamps `t_vec`.

```python
def solve_path(R0, t_vec, x_init=x_0):
    """
    Solve for i(t) and c(t) via numerical integration,
    given the time path for R0.

    """
    G = lambda x, t: F(x, t, R0)
    s_path, e_path, i_path = odeint(G, x_init, t_vec).transpose()

    c_path = 1 - s_path - e_path       # cumulative cases
    return i_path, c_path
```

## Experimental Analysis

Let's carry out some experiments with the following code.

We will investigate a duration of 550 days, which is roughly equivalent to 18 months:

```python
t_length = 550
grid_size = 1000
t_vec = np.linspace(0, t_length, grid_size)
```

### Experiment 1: Constant Reproductive Number (`R0`)

Let's explore scenarios where the reproductive number remains fixed.

We will compute and compare infection timelines across various `R0` values:

```python
R0_vals = np.linspace(1.6, 3.0, 6)
labels = [f'$R0 = {r:.2f}$' for r in R0_vals]
i_paths, c_paths = [], []

for r in R0_vals:
    i_path, c_path = solve_path(r, t_vec)
    i_paths.append(i_path)
    c_paths.append(c_path)
```

### Function for Time Path Visualization

```markdown
This function generates visualizations of time paths.
```

```python
def plot_paths(paths, labels, times=t_vec):

    fig, ax = plt.subplots()

    for path, label in zip(paths, labels):
        ax.plot(times, path, label=label)

    ax.legend(loc='upper left')

    plt.show()
```

Let's visualize the ratio of current cases to total population.

```python
plot_paths(i_paths, labels)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/1.%20Modeling%20COVID%2019_files/1.%20Modeling%20COVID%2019_28_0.png)
</div>

As expected, slower virus spread times lead to a later and less severe outbreak peak.

Let's look at the total number of infected individuals compared to the overall population:

```python
plot_paths(c_paths, labels)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/1.%20Modeling%20COVID%2019_files/1.%20Modeling%20COVID%2019_30_0.png)
</div>

### Experiment 2: Adaptive Response

Let's examine a situation where interventions (such as physical distancing) are progressively put in place.

Below is a function that calculates the basic reproduction number (`R0`) over time:

```python
def R0_mitigating(t, r0=3, η=1, r_bar=1.6):
    R0 = r0 * exp(- η * t) + (1 - exp(- η * t)) * r_bar
    return R0
```

This function simulates an initial `R0` value of 3, which gradually decreases to 1.6 as more stringent control measures are put in place.

The parameter η influences how quickly these restrictions are implemented.

We will investigate various implementation rates:

```python
η_vals = 1/5, 1/10, 1/20, 1/50, 1/100
labels = [fr'$\eta = {η:.2f}$' for η in η_vals]
```

Let's explore how the basic reproduction number (`R0`) evolves over time under various transmission rates:

```python
fig, ax = plt.subplots()

for η, label in zip(η_vals, labels):
    ax.plot(t_vec, R0_mitigating(t_vec, η=η), label=label)

ax.legend()
plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/1.%20Modeling%20COVID%2019_files/1.%20Modeling%20COVID%2019_36_0.png)
</div>

# Calculating the Time Path of Infected Individuals

```python
i_paths, c_paths = [], []

for η in η_vals:
    R0 = lambda t: R0_mitigating(t, η=η)
    i_path, c_path = solve_path(R0, t_vec)
    i_paths.append(i_path)
    c_paths.append(c_path)
```

Here are the current cases under various scenarios:

```python
plot_paths(i_paths, labels)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/1.%20Modeling%20COVID%2019_files/1.%20Modeling%20COVID%2019_40_0.png)
</div>

And here is the breakdown of total cases relative to the overall population:

```python
plot_paths(c_paths, labels)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/1.%20Modeling%20COVID%2019_files/1.%20Modeling%20COVID%2019_42_0.png)
</div>

## Lockdown Termination Analysis

The following replicates additional findings by Andrew Atkeson on the timing of lockdown lifting.

We'll examine two mitigation scenarios:

1.  A 30-day period with a reproduction rate ($R_t$) of 0.5, followed by 17 months at $R_t = 2$ (lifting lockdown after 30 days)

2.  A 120-day period with a reproduction rate ($R_t$) of 0.5, followed by 14 months at $R_t = 2$ (lifting lockdown after 4 months)

These parameters initiate the model with 25,000 active infections and 75,000 individuals already exposed to the virus.

```python
# initial conditions
i_0 = 25_000 / pop_size
e_0 = 75_000 / pop_size
s_0 = 1 - i_0 - e_0
x_0 = s_0, e_0, i_0
```

Let's Determine the Paths:

```python
R0_paths = (lambda t: 0.5 if t < 30 else 2,
            lambda t: 0.5 if t < 120 else 2)

labels = [f'scenario {i}' for i in (1, 2)]

i_paths, c_paths = [], []

for R0 in R0_paths:
    i_path, c_path = solve_path(R0, t_vec, x_init=x_0)
    i_paths.append(i_path)
    c_paths.append(c_path)
```

**Current Infection Statistics:**

```python
plot_paths(i_paths, labels)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/1.%20Modeling%20COVID%2019_files/1.%20Modeling%20COVID%2019_48_0.png)
</div>

Let's consider an assumed case fatality rate of 1%.

```python
ν = 0.01
```

# Cumulative Death Count

This displays the total number of fatalities over time.

```python
paths = [path * ν * pop_size for path in c_paths]
plot_paths(paths, labels)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/1.%20Modeling%20COVID%2019_files/1.%20Modeling%20COVID%2019_52_0.png)
</div>

### Daily Death Rate Displayed

```python
paths = [path * ν * γ * pop_size for path in i_paths]
plot_paths(paths, labels)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/1.%20Modeling%20COVID%2019_files/1.%20Modeling%20COVID%2019_54_0.png)
</div>

Delaying the peak of infections could lead to fewer overall fatalities, assuming a vaccine is introduced during this time period.
