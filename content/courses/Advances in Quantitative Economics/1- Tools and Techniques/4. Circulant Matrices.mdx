---
title: Circulant Matrices
draft: false
summary: test
---

import TOCInline from 'pliny/ui/TOCInline';

<TOCInline toc={props.toc} asDisclosure />

# Introduction to Circulant Matrices

## Summary

This part delves into circulant matrices and their features.

Circulant matrices possess a distinct structure that associates them with key ideas such as:

- convolution
- Fourier transforms
- permutation matrices

Because of these associations, circulant matrices are widely utilized in machine learning, especially in image processing.

We'll begin by loading the necessary Python libraries.

```python
import numpy as np
from numba import njit
import matplotlib.pyplot as plt
```

```python
np.set_printoptions(precision=3, suppress=True)
```

## Constructing a Circulant Matrix

To create an $ N \times N $ circulant matrix, only the first row needs to be defined, for instance,

$$
\begin{bmatrix} c_{0} & c_{1} & c_{2} & c_{3} & c_{4} & \cdots & c_{N-1} \end{bmatrix} .
$$

Once the first row is set, the following rows of the circulant matrix are generated as follows:

$$
C=\left[\begin{array}{ccccccc}
c_{0} & c_{1} & c_{2} & c_{3} & c_{4} & \cdots & c_{N-1}\\
c_{N-1} & c_{0} & c_{1} & c_{2} & c_{3} & \cdots & c_{N-2}\\
c_{N-2} & c_{N-1} & c_{0} & c_{1} & c_{2} & \cdots & c_{N-3}\\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots\\
c_{3} & c_{4} & c_{5} & c_{6} & c_{7} & \cdots & c_{2}\\
c_{2} & c_{3} & c_{4} & c_{5} & c_{6} & \cdots & c_{1}\\
c_{1} & c_{2} & c_{3} & c_{4} & c_{5} & \cdots & c_{0}
\end{array}\right] \tag{4.1}
$$

Alternatively, a circulant matrix can be constructed by defining the transpose of this matrix, requiring only the first column.

Let's implement Python code to create a circulant matrix.

```python
@njit
def construct_cirlulant(row):

    N = row.size

    C = np.empty((N, N))

    for i in range(N):

        C[i, i:] = row[:N-i]
        C[i, :i] = row[N-i:]

    return C
```

```python
# a simple case when N = 3
construct_cirlulant(np.array([1., 2., 3.]))
```

    array([[1., 2., 3.],
           [3., 1., 2.],
           [2., 3., 1.]])

### Notable Attributes of Circulant Matrices

Some key properties include:

If $ A $ and $ B $ are both circulant matrices, it can be demonstrated that

- The transpose of a circulant matrix is also circulant
- $ A + B $ results in a circulant matrix
- $ A B $ results in a circulant matrix
- $ A B = B A $

Now, consider a circulant matrix with the first row

$$
c = \begin{bmatrix} c_0 & c_1 & \cdots & c_{N-1} \end{bmatrix}
$$

and a vector

$$
a = \begin{bmatrix} a_0 & a_1 & \cdots & a_{N-1} \end{bmatrix}
$$

The **convolution** of vectors $ c $ and $ a $ is defined as the vector $ b = c \* a $ with components

$$
b_k = \sum_{i=0}^{n-1} c_{k-i} a_i \tag{4.2}
$$

We use $ \* $ to indicate **convolution** as described in equation [(4.2)](#equation-eqn-conv).

It can be shown that the vector $ b $ satisfies

$$
b = C^T a
$$

where $ C^T $ is the transpose of the circulant matrix defined in equation [(4.1)](#equation-eqn-circulant).

## Link to Permutation Matrix

A useful way to build a circulant matrix is by utilizing a **permutation matrix**.

Before defining a permutation **matrix**, let's define a **permutation**.

A **permutation** of a set of non-negative integers $ \{0, 1, 2, \ldots \} $ is a one-to-one mapping of the set onto itself.

A permutation of a set $ \{1, 2, \ldots, n\} $ rearranges the $ n $ integers in the set.

A [permutation matrix](https://mathworld.wolfram.com/PermutationMatrix.html) is formed by permuting the rows of an $ n \times n $ identity matrix according to a permutation of the numbers $ 1 $ to $ n $.

As a result, each row and each column contains exactly one $ 1 $ with $ 0 $ everywhere else.

Every permutation corresponds to a unique permutation matrix.

For example, the $ N \times N $ matrix

$$
P=\left[\begin{array}{cccccc}
0 & 1 & 0 & 0 & \cdots & 0\\
0 & 0 & 1 & 0 & \cdots & 0\\
0 & 0 & 0 & 1 & \cdots & 0\\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots\\
0 & 0 & 0 & 0 & \cdots & 1\\
1 & 0 & 0 & 0 & \cdots & 0
\end{array}\right] \tag{4.3}
$$

acts as a **cyclic shift** operator that, when applied to an $ N \times 1 $ vector $ h $, shifts entries in rows $ 2 $ through $ N $ up one row and moves the entry in row $ 1 $ to row $ N $.

Eigenvalues of the cyclic shift permutation matrix $ P $ defined in equation [(4.3)](#equation-eqn-examplep) can be determined by constructing

$$
P-\lambda I=\left[\begin{array}{cccccc}
-\lambda & 1 & 0 & 0 & \cdots & 0\\
0 & -\lambda & 1 & 0 & \cdots & 0\\
0 & 0 & -\lambda & 1 & \cdots & 0\\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots\\
0 & 0 & 0 & 0 & \cdots & 1\\
1 & 0 & 0 & 0 & \cdots & -\lambda
\end{array}\right]
$$

and solving

$$
\textrm{det}(P - \lambda I) = (-1)^N \lambda^{N}-1=0
$$

Eigenvalues $ \lambda_i $ can be complex.

Magnitudes $ \mid \lambda_i \mid $ of these eigenvalues $ \lambda_i $ are all equal to $ 1 $.

Therefore, **singular values** of the permutation matrix $ P $ defined in equation [(4.3)](#equation-eqn-examplep) are all equal to $ 1 $.

It can be proven that permutation matrices are orthogonal matrices:

$$
P P' = I
$$

## Real-World Examples in Python

Let's create some Python code to demonstrate these ideas.

```python
@njit
def construct_P(N):

    P = np.zeros((N, N))

    for i in range(N-1):
        P[i, i+1] = 1
    P[-1, 0] = 1

    return P
```

```python
P4 = construct_P(4)
P4
```

    array([[0., 1., 0., 0.],
           [0., 0., 1., 0.],
           [0., 0., 0., 1.],
           [1., 0., 0., 0.]])

```python
# compute the eigenvalues and eigenvectors
ùúÜ, Q = np.linalg.eig(P4)
```

```python
for i in range(4):
    print(f'ùúÜ{i} = {ùúÜ[i]:.1f} \nvec{i} = {Q[i, :]}\n')
```

    ùúÜ0 = -1.0+0.0j
    vec0 = [0.5+0.j 0.5+0.j 0.5-0.j 0.5+0.j]

    ùúÜ1 = 0.0+1.0j
    vec1 = [-0.5+0.j  -0. +0.5j -0. -0.5j  0.5+0.j ]

    ùúÜ2 = 0.0-1.0j
    vec2 = [ 0.5+0.j -0.5+0.j -0.5-0.j  0.5+0.j]

    ùúÜ3 = 1.0+0.0j
    vec3 = [-0.5+0.j  -0. -0.5j -0. +0.5j  0.5+0.j ]

In the following plots, we will show the eigenvalues of a shift permutation matrix on the complex plane.

These eigenvalues are evenly spaced around the unit circle.

They are the **$ n $ roots of unity**, meaning they are the $ n $ numbers $ z $ that solve $ z^n =1 $, where $ z $ is a complex number.

Specifically, the $ n $ roots of unity are

$$
z = \exp\left(\frac{2 \pi j k }{N} \right) , \quad k = 0, \ldots, N-1
$$

where $ j $ represents the purely imaginary unit number.

```python
fig, ax = plt.subplots(2, 2, figsize=(10, 10))

for i, N in enumerate([3, 4, 6, 8]):

    row_i = i // 2
    col_i = i % 2

    P = construct_P(N)
    ùúÜ, Q = np.linalg.eig(P)

    circ = plt.Circle((0, 0), radius=1, edgecolor='b', facecolor='None')
    ax[row_i, col_i].add_patch(circ)

    for j in range(N):
        ax[row_i, col_i].scatter(ùúÜ[j].real, ùúÜ[j].imag, c='b')

    ax[row_i, col_i].set_title(f'N = {N}')
    ax[row_i, col_i].set_xlabel('real')
    ax[row_i, col_i].set_ylabel('imaginary')

plt.show()
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/4.%20Circulant%20Matrices_files/4.%20Circulant%20Matrices_15_0.png)
</div>

For a vector of coefficients $ \{c*i\}*{i=0}^{n-1} $, eigenvectors of $ P $ are also eigenvectors of

$$
C = c_{0} I + c_{1} P + c_{2} P^{2} +\cdots + c_{N-1} P^{N-1}.
$$

Let's consider an example where $ N=8 $ and let $ w = e^{-2 \pi j / N} $.

It can be shown that the matrix $ F*8 $ of eigenvectors of $ P*{8} $ is

$$
F_{8}=\left[\begin{array}{ccccc}
1 & 1 & 1 & \cdots & 1\\
1 & w & w^{2} & \cdots & w^{7}\\
1 & w^{2} & w^{4} & \cdots & w^{14}\\
1 & w^{3} & w^{6} & \cdots & w^{21}\\
1 & w^{4} & w^{8} & \cdots & w^{28}\\
1 & w^{5} & w^{10} & \cdots & w^{35}\\
1 & w^{6} & w^{12} & \cdots & w^{42}\\
1 & w^{7} & w^{14} & \cdots & w^{49}
\end{array}\right]
$$

The matrix $ F_8 $ defines a [Discrete Fourier Transform](https://en.wikipedia.org/wiki/Discrete_Fourier_transform).

To convert it into an orthogonal eigenvector matrix, we can simply normalize it by dividing every entry by $ \sqrt{8} $.

- examine the first column of $ F_8 $ above to confirm this fact

The eigenvalues corresponding to each eigenvector are $ \{w^{j}\}\_{j=0}^{7} $ in order.

```python
def construct_F(N):

    w = np.e ** (-complex(0, 2*np.pi/N))

    F = np.ones((N, N), dtype=complex)
    for i in range(1, N):
        F[i, 1:] = w ** (i * np.arange(1, N))

    return F, w
```

```python
F8, w = construct_F(8)
```

```python
w
```

    (0.7071067811865476-0.7071067811865475j)

```python
F8
```

    array([[ 1.   +0.j   ,  1.   +0.j   ,  1.   +0.j   ,  1.   +0.j   ,
             1.   +0.j   ,  1.   +0.j   ,  1.   +0.j   ,  1.   +0.j   ],
           [ 1.   +0.j   ,  0.707-0.707j,  0.   -1.j   , -0.707-0.707j,
            -1.   -0.j   , -0.707+0.707j, -0.   +1.j   ,  0.707+0.707j],
           [ 1.   +0.j   ,  0.   -1.j   , -1.   -0.j   , -0.   +1.j   ,
             1.   +0.j   ,  0.   -1.j   , -1.   -0.j   , -0.   +1.j   ],
           [ 1.   +0.j   , -0.707-0.707j, -0.   +1.j   ,  0.707-0.707j,
            -1.   -0.j   ,  0.707+0.707j,  0.   -1.j   , -0.707+0.707j],
           [ 1.   +0.j   , -1.   -0.j   ,  1.   +0.j   , -1.   -0.j   ,
             1.   +0.j   , -1.   -0.j   ,  1.   +0.j   , -1.   -0.j   ],
           [ 1.   +0.j   , -0.707+0.707j,  0.   -1.j   ,  0.707+0.707j,
            -1.   -0.j   ,  0.707-0.707j, -0.   +1.j   , -0.707-0.707j],
           [ 1.   +0.j   , -0.   +1.j   , -1.   -0.j   ,  0.   -1.j   ,
             1.   +0.j   , -0.   +1.j   , -1.   -0.j   ,  0.   -1.j   ],
           [ 1.   +0.j   ,  0.707+0.707j, -0.   +1.j   , -0.707+0.707j,
            -1.   -0.j   , -0.707-0.707j,  0.   -1.j   ,  0.707-0.707j]])

```python
# normalize
Q8 = F8 / np.sqrt(8)
```

```python
# verify the orthogonality (unitarity)
Q8 @ np.conjugate(Q8)
```

    array([[ 1.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,  0.+0.j,  0.+0.j,
             0.+0.j],
           [-0.-0.j,  1.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,  0.+0.j,
             0.+0.j],
           [-0.-0.j, -0.-0.j,  1.-0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,
             0.+0.j],
           [-0.-0.j, -0.-0.j, -0.-0.j,  1.-0.j, -0.+0.j, -0.+0.j, -0.+0.j,
            -0.+0.j],
           [-0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,  1.+0.j, -0.+0.j, -0.+0.j,
            -0.+0.j],
           [ 0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,  1.+0.j, -0.+0.j,
            -0.+0.j],
           [ 0.-0.j,  0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,  1.+0.j,
            -0.+0.j],
           [ 0.-0.j,  0.-0.j,  0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,
             1.-0.j]])

Let's verify that the $ k $th column of $ Q*{8} $ is indeed an eigenvector of $ P*{8} $ with the eigenvalue $ w^{k} $.

```python
P8 = construct_P(8)
```

```python
diff_arr = np.empty(8, dtype=complex)
for j in range(8):
    diff = P8 @ Q8[:, j] - w ** j * Q8[:, j]
    diff_arr[j] = diff @ diff.T
```

```python
diff_arr
```

    array([ 0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,
           -0.+0.j])

## Associated Permutation Matrix

Next, we will perform calculations to confirm that the circulant matrix $ C $ defined in equation [(4.1)](#equation-eqn-circulant) can be represented as

$$
C = c_{0} I + c_{1} P + \cdots + c_{n-1} P^{n-1}
$$

and that each eigenvector of $ P $ is also an eigenvector of $ C $.

We will demonstrate this for the case when $ N=8 $.

```python
c = np.random.random(8)
```

```python
c
```

    array([0.968, 0.732, 0.133, 0.851, 0.015, 0.598, 0.011, 0.116])

```python
C8 = construct_cirlulant(c)
```

Compute $ c*{0} I + c*{1} P + \cdots + c\_{n-1} P^{n-1} $.

```python
N = 8

C = np.zeros((N, N))
P = np.eye(N)

for i in range(N):
    C += c[i] * P
    P = P8 @ P
```

```python
C
```

    array([[0.968, 0.732, 0.133, 0.851, 0.015, 0.598, 0.011, 0.116],
           [0.116, 0.968, 0.732, 0.133, 0.851, 0.015, 0.598, 0.011],
           [0.011, 0.116, 0.968, 0.732, 0.133, 0.851, 0.015, 0.598],
           [0.598, 0.011, 0.116, 0.968, 0.732, 0.133, 0.851, 0.015],
           [0.015, 0.598, 0.011, 0.116, 0.968, 0.732, 0.133, 0.851],
           [0.851, 0.015, 0.598, 0.011, 0.116, 0.968, 0.732, 0.133],
           [0.133, 0.851, 0.015, 0.598, 0.011, 0.116, 0.968, 0.732],
           [0.732, 0.133, 0.851, 0.015, 0.598, 0.011, 0.116, 0.968]])

```python
C8
```

    array([[0.968, 0.732, 0.133, 0.851, 0.015, 0.598, 0.011, 0.116],
           [0.116, 0.968, 0.732, 0.133, 0.851, 0.015, 0.598, 0.011],
           [0.011, 0.116, 0.968, 0.732, 0.133, 0.851, 0.015, 0.598],
           [0.598, 0.011, 0.116, 0.968, 0.732, 0.133, 0.851, 0.015],
           [0.015, 0.598, 0.011, 0.116, 0.968, 0.732, 0.133, 0.851],
           [0.851, 0.015, 0.598, 0.011, 0.116, 0.968, 0.732, 0.133],
           [0.133, 0.851, 0.015, 0.598, 0.011, 0.116, 0.968, 0.732],
           [0.732, 0.133, 0.851, 0.015, 0.598, 0.011, 0.116, 0.968]])

Now, let's calculate the difference between two circulant matrices that we have constructed using different methods.

```python
np.abs(C - C8).max()
```

    0.0

The $ k $th column of $ P*{8} $ associated with the eigenvalue $ w^{k-1} $ is an eigenvector of $ C*{8} $ related to an eigenvalue $ \sum*{h=0}^{7} c*{j} w^{h k} $.

```python
ùúÜ_C8 = np.zeros(8, dtype=complex)

for j in range(8):
    for k in range(8):
        ùúÜ_C8[j] += c[k] * w ** (j * k)
```

```python
ùúÜ_C8
```

    array([ 3.425+0.j   ,  0.529-0.736j,  0.84 -0.363j,  1.378-0.492j,
           -1.17 -0.j   ,  1.378+0.492j,  0.84 +0.363j,  0.529+0.736j])

We can verify this by comparing `C8 @ Q8[:, j]` with `ùúÜ_C8[j] * Q8[:, j]`.

```python
# verify
for j in range(8):
    diff = C8 @ Q8[:, j] - ùúÜ_C8[j] * Q8[:, j]
    print(diff)
```

    [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]
    [-0.-0.j -0.+0.j -0.+0.j -0.-0.j -0.-0.j -0.-0.j -0.-0.j -0.-0.j]
    [ 0.+0.j  0.-0.j -0.+0.j  0.-0.j -0.+0.j -0.-0.j -0.-0.j -0.-0.j]
    [ 0.+0.j  0.-0.j -0.+0.j  0.-0.j -0.+0.j  0.-0.j -0.-0.j  0.-0.j]
    [ 0.-0.j -0.+0.j  0.-0.j  0.-0.j  0.+0.j  0.-0.j  0.+0.j  0.-0.j]
    [ 0.+0.j -0.-0.j  0.+0.j -0.-0.j  0.+0.j -0.-0.j  0.+0.j -0.-0.j]
    [0.-0.j 0.-0.j 0.-0.j 0.-0.j 0.+0.j 0.-0.j 0.-0.j 0.-0.j]
    [-0.-0.j  0.-0.j  0.-0.j  0.-0.j  0.-0.j  0.-0.j  0.-0.j  0.-0.j]

## Discrete Fourier Transform

The **Discrete Fourier Transform** (DFT) allows us to express a discrete time sequence as a combination of complex sinusoids.

Consider a sequence of $ N $ real numbers $ \{x*j\}*{j=0}^{N-1} $.

The **Discrete Fourier Transform** converts $ \{x*j\}*{j=0}^{N-1} $ into a sequence of complex numbers $ \{X*k\}*{k=0}^{N-1} $

where

$$
X_{k}=\sum_{n=0}^{N-1}x_{n}e^{-2\pi\frac{kn}{N}i}
$$

```python
def DFT(x):
    "The discrete Fourier transform."

    N = len(x)
    w = np.e ** (-complex(0, 2*np.pi/N))

    X = np.zeros(N, dtype=complex)
    for k in range(N):
        for n in range(N):
            X[k] += x[n] * w ** (k * n)

    return X
```

Let's consider the following example.

$$
x_{n}=\begin{cases}
1/2 & n=0,1\\
0 & \text{otherwise}
\end{cases}
$$

```python
x = np.zeros(10)
x[0:2] = 1/2
```

```python
x
```

    array([0.5, 0.5, 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ])

Implement a discrete Fourier transform.

```python
X = DFT(x)
```

```python
X
```

    array([ 1.   +0.j   ,  0.905-0.294j,  0.655-0.476j,  0.345-0.476j,
            0.095-0.294j, -0.   -0.j   ,  0.095+0.294j,  0.345+0.476j,
            0.655+0.476j,  0.905+0.294j])

We can visualize the magnitudes of a sequence of numbers and the corresponding discrete Fourier transform.

```python
def plot_magnitude(x=None, X=None):

    data = []
    names = []
    xs = []
    if (x is not None):
        data.append(x)
        names.append('x')
        xs.append('n')
    if (X is not None):
        data.append(X)
        names.append('X')
        xs.append('j')

    num = len(data)
    for i in range(num):
        n = data[i].size
        plt.figure(figsize=(8, 3))
        plt.scatter(range(n), np.abs(data[i]))
        plt.vlines(range(n), 0, np.abs(data[i]), color='b')

        plt.xlabel(xs[i])
        plt.ylabel('magnitude')
        plt.title(names[i])
        plt.show()
```

```python
plot_magnitude(x=x, X=X)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/4.%20Circulant%20Matrices_files/4.%20Circulant%20Matrices_52_0.png)
</div>

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/4.%20Circulant%20Matrices_files/4.%20Circulant%20Matrices_52_1.png)
</div>

The **inverse Fourier transform** is used to convert a Fourier transform $ X $ back into the original sequence $ x $.

The inverse Fourier transform is defined as

$$
x_{n} = \sum_{k=0}^{N-1} \frac{1}{N} X_{k} e^{2\pi\left(\frac{kn}{N}\right)i}, \quad n=0, 1, \ldots, N-1
$$

```python
def inverse_transform(X):

    N = len(X)
    w = np.e ** (complex(0, 2*np.pi/N))

    x = np.zeros(N, dtype=complex)
    for n in range(N):
        for k in range(N):
            x[n] += X[k] * w ** (k * n) / N

    return x
```

```python
inverse_transform(X)
```

    array([ 0.5+0.j,  0.5-0.j, -0. -0.j, -0. +0.j, -0. +0.j, -0. +0.j,
           -0. +0.j, -0. +0.j, -0. +0.j,  0. +0.j])

Consider another example:

$$
x_{n}=2\cos\left(2\pi\frac{11}{40}n\right),\ n=0,1,2,\cdots19
$$

Since $ N=20 $, we can't represent a frequency of $ \frac{11}{40} $ using an integer multiple of $ \frac{1}{20} $.

To resolve this, we need to utilize all $ N $ frequencies available in the DFT.

Because $ \frac{11}{40} $ is between $ \frac{10}{40} $ and $ \frac{12}{40} $ (both of which are integer multiples of $ \frac{1}{20} $), the largest magnitudes of the complex coefficients in the DFT occur at $ k=5,6,15,16 $, rather than at a single frequency.

```python
N = 20
x = np.empty(N)

for j in range(N):
    x[j] = 2 * np.cos(2 * np.pi * 11 * j / 40)
```

```python
X = DFT(x)
```

```python
plot_magnitude(x=x, X=X)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/4.%20Circulant%20Matrices_files/4.%20Circulant%20Matrices_59_0.png)
</div>

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/4.%20Circulant%20Matrices_files/4.%20Circulant%20Matrices_59_1.png)
</div>

What if we change the previous example to $ x\_{n}=2\cos\left(2\pi\frac{10}{40}n\right) $?

Note that $ \frac{10}{40} $ is an integer multiple of $ \frac{1}{20} $.

```python
N = 20
x = np.empty(N)

for j in range(N):
    x[j] = 2 * np.cos(2 * np.pi * 10 * j / 40)
```

```python
X = DFT(x)
```

```python
plot_magnitude(x=x, X=X)
```

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/4.%20Circulant%20Matrices_files/4.%20Circulant%20Matrices_63_0.png)
</div>

<div
  className="my-1 overflow-hidden px-2 xl:my-1 xl:w-1/2 xl:px-2"
  style={{
    display: 'block',
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '90%',
    alignItems: 'center',
    justifyContent: 'center',
  }}
>
  ![png](/static/courses/Advances%20in%20Quantitative%20Economics/4.%20Circulant%20Matrices_files/4.%20Circulant%20Matrices_63_1.png)
</div>

When we express the discrete Fourier transform as a matrix, it corresponds to the matrix $ F*{N} $, which contains the eigenvectors of the permutation matrix $ P*{N} $.

To illustrate this, consider an example where $ x\_{n}=2\cos\left(2\pi\frac{11}{40}n\right),\ n=0,1,2,\cdots19 $.

```python
N = 20
x = np.empty(N)

for j in range(N):
    x[j] = 2 * np.cos(2 * np.pi * 11 * j / 40)
```

```python
x
```

    array([ 2.   , -0.313, -1.902,  0.908,  1.618, -1.414, -1.176,  1.782,
            0.618, -1.975, -0.   ,  1.975, -0.618, -1.782,  1.176,  1.414,
           -1.618, -0.908,  1.902,  0.313])

Start by using the summation formula to transform $ x $ into $ X $.

```python
X = DFT(x)
X
```

    array([2. +0.j   , 2. +0.558j, 2. +1.218j, 2. +2.174j, 2. +4.087j,
           2.+12.785j, 2.-12.466j, 2. -3.751j, 2. -1.801j, 2. -0.778j,
           2. -0.j   , 2. +0.778j, 2. +1.801j, 2. +3.751j, 2.+12.466j,
           2.-12.785j, 2. -4.087j, 2. -2.174j, 2. -1.218j, 2. -0.558j])

Next, let's look at the result of multiplying the eigenvector matrix $ F*{20} $ by the vector $ x $. We claim that this product should be equivalent to the Fourier transform of the sequence $ \{x_n\}*{n=0}^{N-1} $.

```python
F20, _ = construct_F(20)
```

```python
F20 @ x
```

    array([2. +0.j   , 2. +0.558j, 2. +1.218j, 2. +2.174j, 2. +4.087j,
           2.+12.785j, 2.-12.466j, 2. -3.751j, 2. -1.801j, 2. -0.778j,
           2. -0.j   , 2. +0.778j, 2. +1.801j, 2. +3.751j, 2.+12.466j,
           2.-12.785j, 2. -4.087j, 2. -2.174j, 2. -1.218j, 2. -0.558j])

Similarly, the inverse DFT can be represented as an inverse DFT matrix $ F^{-1}\_{20} $.

```python
F20_inv = np.linalg.inv(F20)
F20_inv @ X
```

    array([ 2.   +0.j, -0.313+0.j, -1.902+0.j,  0.908+0.j,  1.618-0.j,
           -1.414+0.j, -1.176-0.j,  1.782-0.j,  0.618+0.j, -1.975+0.j,
           -0.   -0.j,  1.975+0.j, -0.618+0.j, -1.782-0.j,  1.176-0.j,
            1.414+0.j, -1.618+0.j, -0.908-0.j,  1.902-0.j,  0.313+0.j])
